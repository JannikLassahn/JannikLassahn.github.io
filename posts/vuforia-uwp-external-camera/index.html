<!doctype html><html lang=en>
<head>
<title>
Integrating external cameras in Vuforia UWP apps ::
Jannik Lassahn
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="I recently had the chance to work on an interesting and challenging project. I didn&amp;rsquo;t expect to encounter so many roadblocks though, that&amp;rsquo;s why I would like to share some learnings.
The team behind the aforementioned project were in the middle of creating an interactive installation for a museum. They wanted visitors to be able to place certain items on on a desk and project contextual information depending on where the item was placed.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://janniklassahn.com/posts/vuforia-uwp-external-camera/>
<link rel=stylesheet href=https://janniklassahn.com/assets/style.css>
<link rel=stylesheet href=https://janniklassahn.com/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=https://janniklassahn.com/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=https://janniklassahn.com/img/favicon.png>
<link href=https://janniklassahn.com/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://janniklassahn.com/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://janniklassahn.com/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://janniklassahn.com/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://janniklassahn.com/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://janniklassahn.com/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Integrating external cameras in Vuforia UWP apps">
<meta name=twitter:description content="A story about using unsupported cameras with Vuforia and UWP">
<meta property="og:title" content="Integrating external cameras in Vuforia UWP apps">
<meta property="og:description" content="A story about using unsupported cameras with Vuforia and UWP">
<meta property="og:type" content="article">
<meta property="og:url" content="https://janniklassahn.com/posts/vuforia-uwp-external-camera/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-09T00:00:00+00:00">
<meta property="article:modified_time" content="2021-11-09T00:00:00+00:00">
</head>
<body class=dark-theme>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__text>Jannik Lassahn</span>
</a>
<span class=header__right>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>Integrating external cameras in Vuforia UWP apps</h1>
<div class=post-meta>
<span class=post-date>
09. Nov 2021
</span>
</div>
<span class=post-tags>
<a href=https://janniklassahn.com/tags/vuforia/>#vuforia</a>&nbsp;
<a href=https://janniklassahn.com/tags/uwp/>#uwp</a>&nbsp;
<a href=https://janniklassahn.com/tags/ipc/>#ipc</a>&nbsp;
</span>
<div class=post-content>
<p>I recently had the chance to work on an interesting and challenging project. I didn&rsquo;t expect to encounter so many roadblocks though, that&rsquo;s why I would like to share some learnings.</p>
<p>The team behind the aforementioned project were in the middle of creating an interactive installation for a museum.
They wanted visitors to be able to place certain items on on a desk and project contextual information depending on where the item was placed.
Naturally, they used Vuforia to do the tracking. There was just a tiny problem: Vuforia couldn&rsquo;t connect to the camera.</p>
<h3 id=down-the-rabbit-hole>Down the rabbit hole</h3>
<p>Here&rsquo;s the setup: the camera is an industrial-grade infrared camera from Allied Vision. Its primary output format is <em>Mono8</em>, where each pixel takes up 8 bits. If you need more precision, the camera also supports <em>Mono10</em> and <em>Mono12</em>, where each pixel gets 10 or 12 bits respectively. Since it&rsquo;s an infrared camera this makes perfectly sense: you don&rsquo;t need to account for color channels. As you can see below, rendering infrared, or intensity-based data in general, results in a grayscale image.</p>
<p><img src=https://upload.wikimedia.org/wikipedia/commons/e/ea/Duisburg_Lehmbruck_IR_IR.JPG alt="Infrared example"><em>Source: Wikipedia</em></p>
<p>Sadly, Vuforia only supports common video formats meant to contain color, like RGB24 or YUYV, out of the box. And as we just discovered, <em>Mono8</em> isn&rsquo;t one of them. Fortunately, Vuforia allows developers to hook into the frame capture process by writing a &ldquo;Custom Driver&rdquo;. You can learn more about the External Camera feature in their excellent <a href=https://library.vuforia.com/articles/Solution/creating-custom-driver.html>documentation</a>.</p>
<p>For now, my plan of attack was to write a driver. The target device was a Windows 10 machine, so this driver had to be implemented using Universal Windows Platform (UWP) APIs.</p>
<h3 id=the-pool-of-tears>The pool of tears</h3>
<p>Using the <code>MediaCapture</code> API, more specifically the <code>MediaFrameReader</code>, we can stream all sorts of camera data in UWP apps. In theory, you would get all possible camera sources with <code>MediaFrameSourceGroup.FindAllAsync()</code>, filter out the appropriate camera and the desired source kind, in my case <code>MediaFrameSourceKind.Infrared</code>, initialize a <code>MediaCapture</code> object, then create and start the <code>MediaFrameReader</code> object.</p>
<p>I already had some experience using this API because of a <a href=https://github.com/JannikLassahn/vuforia-uwp-driver>side project</a>, where I tried to create my own Vuforia driver for UWP. So, I used the existing code in the hopes of it &ldquo;just working&rdquo;. It was at this point that I noticed that the camera refused to show up in any API calls. To see exactly why, I have to go a bit on a tangent:</p>
<p>Apparently, a manufacturer has to provide a special kind of capture driver, also known as a <em>Device Media Foundation transform (MFT)</em>. The MFT uses various attributes to let Windows know what kind of functionality a camera device supports. Windows is then able to let apps access this functionality in a secure manner through the likes of <code>MediaCapture</code>. This might be the reason most Virtual Webcam solutions won&rsquo;t work with UWP. OBS, for example, only provides a DirectShow output. My camera was, as far as Windows was concerned, just a generic USB device. MFT is a powerful framework, but also very complex. With my non-existent experience in this field I couldn&rsquo;t estimate the overall time and effort necessary to implement a reliable solution. Not particularly reassuring with a deadline around the corner.</p>
<hr>
<p>Next idea:
I tried to use the manufacturers SDK directly within the Vuforia custom driver and ended up generating a lot of exceptions, but not a single frame. The SDK was using a lot of APIs to connect to the camera that simply aren&rsquo;t allowed with UWP apps. I&rsquo;m almost certain the underlying Boost libraries were the root cause in this case.</p>
<p>The sensible thing to do in this situation is, of course, to panic. Here I was without a way to access the camera in my UWP app, despite all the extension points of Vuforia. If I just could write a regular application without security restrictions, one that can do whatever I want it to do&mldr;</p>
<h3 id=a-mad-tea-party>A mad tea party</h3>
<p>Incidentally, Microsoft realized this issue over two years ago and resolved it by introducing the <a href=https://techcommunity.microsoft.com/t5/windows-dev-appconsult/desktop-bridge-8211-the-bridge-between-desktop-apps-and-the/ba-p/316488>UWP Desktop Bridge</a>. The desktop bridge enables developers to combine traditional desktop apps (&ldquo;Win32 apps&rdquo;) and new UWP apps in various ways.</p>
<p>The desktop bridge is <em>exactly</em> what I needed. The solution to my problem wouldn&rsquo;t have been possible without it.</p>
<p>Here&rsquo;s how everything comes together:</p>
<p><img src=/img/vuforia_external_camera_diagram.jpg alt=Architecture></p>
<ol>
<li>the UWP host app invokes Vuforia</li>
<li>Vuforia loads the driver and calls lifecycle methods of the driver framework</li>
<li>the driver sends requests to the Win32 process via app service connection</li>
<li>the Win32 process handles requests and uses the manufacturers SDK to talk to the camera</li>
<li>the converted camera frames are stored in shared memory (if the camera is running)</li>
<li>the Win32 process sends responses via app service connection</li>
<li>the driver reads camera frames from shared memory (if the camera is running)</li>
<li>the driver responds to Vuforia</li>
</ol>
<p>Following this architecture, the two components I had to implement were the custom driver for Vuforia, which is running inside the UWP host, and a Win32 app.
You can think of the UWP driver as client and the Win32 app as server: the client sends commands from Vuforia to the server, the server processes the request and sends back a response.
Since both Vuforia and the camera SDK use C++ I decided to follow suit. This is where the last piece of the puzzle comes into play.</p>
<p>In addition to the desktop bridge, Microsoft also created C++/WinRT, a <a href=https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/>language projection for the Windows Runtime</a> to be able to access all the UWP APIs from standard C++. To quote the documentation:</p>
<blockquote>
<p>&ldquo;[C++/WinRT] is for any developer interested in writing beautiful and fast code for Windows&rdquo;</p>
</blockquote>
<p>Consuming the Windows Runtime APIs this way is actually pleasant. So pleasant in fact, that I recently ported my Vuforia UWP Driver on GitHub from the rather awkward C++/CX to C++/WinRT.</p>
<h4 id=initial-setup>Initial setup</h4>
<p>I&rsquo;m using the <em>Windows Runtime Component</em> template for the driver and the <em>Windows Console Application</em> template for the server:</p>
<p><img src=/img/vuforia_external_camera_create_project.jpg alt=Project></p>
<blockquote>
<p>Tip: use the <em>Shared Items Project</em> in Visual Studio for common files that are used by the server as well as the client.</p>
</blockquote>
<p>Before diving into the actual code though, we have to edit the <code>Package.appxmanifest</code> of the host application. Also, some changes we&rsquo;ll make to the manifest are not supported by the Visual Studio UI, so we&rsquo;ll have to edit the XML manually.</p>
<p>First, we need to register a <em>fullTrustProcess</em> extension to be able to launch the server executable (the .exe of the console project) and an <em>appService</em> extension for the communication between driver and server.
Make sure to include the executable, and its dependencies, in your project, otherwise your app won&rsquo;t be able to run it.</p>
<p>We also need two additional capabilities: <em>codeGeneration</em> and <em>runFullTrust</em>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#75715e>&lt;!-- don&#39;t forget to include XML namespaces 
</span><span style=color:#75715e>for &#34;desktop&#34; and &#34;rescap&#34; in the root node --&gt;</span>

<span style=color:#f92672>&lt;Extensions&gt;</span>
    <span style=color:#f92672>&lt;desktop:Extension</span>  <span style=color:#a6e22e>Category=</span><span style=color:#e6db74>&#34;windows.fullTrustProcess&#34;</span> <span style=color:#a6e22e>Executable=</span><span style=color:#e6db74>&#34;Server.exe&#34;</span> <span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;uap:Extension</span> <span style=color:#a6e22e>Category=</span><span style=color:#e6db74>&#34;windows.appService&#34;</span><span style=color:#f92672>&gt;</span>
        <span style=color:#f92672>&lt;uap:AppService</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;ServerService&#34;</span> <span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;/uap:Extension&gt;</span>
<span style=color:#f92672>&lt;/Extensions&gt;</span>

<span style=color:#f92672>&lt;Capabilities&gt;</span>
    <span style=color:#f92672>&lt;Capability</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;codeGeneration&#34;</span><span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;rescap:Capability</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;runFullTrust&#34;</span> <span style=color:#f92672>/&gt;</span>
<span style=color:#f92672>&lt;/Capabilities&gt;</span>
</code></pre></div><h4 id=client--server-communication>Client / Server communication</h4>
<p>To launch the server process from within driver, we can use the <code>FullTrustProcessLauncher</code> API. In this case, the server will initiate the app service connection after its launch, so we&rsquo;re also registering appropriate event handlers.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// listen to the activation of an app service and launch Win32 process
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>LaunchServer()
{
    CoreApplication<span style=color:#f92672>::</span>BackgroundActivated({ <span style=color:#66d9ef>this</span>, <span style=color:#f92672>&amp;</span>Driver<span style=color:#f92672>::</span>OnBackgroundActivated });
    FullTrustProcessLauncher<span style=color:#f92672>::</span>LaunchFullTrustProcessForCurrentAppAsync();
}

<span style=color:#75715e>// store app service connection object
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>OnBackgroundActivated(IInspectable <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span>, BackgroundActivatedEventArgs <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> e)
{
    <span style=color:#66d9ef>auto</span> details <span style=color:#f92672>=</span> e.TaskInstance().TriggerDetails().as<span style=color:#f92672>&lt;</span>AppServiceTriggerDetails<span style=color:#f92672>&gt;</span>();
    m_connection <span style=color:#f92672>=</span> details.AppServiceConnection();
}
</code></pre></div><p>I&rsquo;m using app service as transport, because it&rsquo;s flexible and easy to use. The OS handles pretty much everything for us.</p>
<p>To initiate the app connection from the server we just have to provide the package family name and the name of the app service.
The family package name matches the family name of the app that deployed the EXE. The app service name has to match the name specified in <code>Package.appxmanifest</code>.
Right after the app service object is set up, the server will send a special message to the driver to confirm a successful launch.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Server<span style=color:#f92672>::</span>PrepareAppServiceConnection()
{
    m_connection <span style=color:#f92672>=</span> AppServiceConnection();
    m_connection.PackageFamilyName(Package<span style=color:#f92672>::</span>Current().Id().FamilyName());
    m_connection.AppServiceName(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;ServerService&#34;</span>);
    m_connection.RequestReceived({ <span style=color:#66d9ef>this</span>, <span style=color:#f92672>&amp;</span>Server<span style=color:#f92672>::</span>OnAppServiceRequest });

    <span style=color:#75715e>// send an initial message to confirm launch...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> message <span style=color:#f92672>=</span> ValueSet();
    message.Insert(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;LAUNCH&#34;</span>, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;SUCCESS&#34;</span>);
    m_connection.SendMessageAsync(message);
}
</code></pre></div><p>Back on the driver side we can use the connection object to communicate with the server process.
For example, if we wanted to command the server to start the camera when Vuforia wants it, we might write the following code in the driver:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>bool</span> VUFORIA_DRIVER_CALLING_CONVENTION <span style=color:#a6e22e>start</span>(VuforiaDriver<span style=color:#f92672>::</span>CameraMode, VuforiaDriver<span style=color:#f92672>::</span>CameraCallback<span style=color:#f92672>*</span> cb)
{
    <span style=color:#75715e>// store camera mode and camera callback
</span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// send request to open the camera
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> message <span style=color:#f92672>=</span> ValueSet();
    message.Insert(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;COMMAND&#34;</span>, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;START&#34;</span>);
    <span style=color:#75715e>//  ... insert more data ...
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// wait for response (blocking)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> response <span style=color:#f92672>=</span> m_connection.SendMessageAsync(message).get();

    <span style=color:#75715e>// parse response
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> IsSuccess(response);
}
</code></pre></div><p>You can put in any key-value pair in <code>ValueSet</code>, as long as its a supported WinRT type. I&rsquo;ve decided to always send the key <code>COMMAND</code> with a value indicating which command it is. In this case the command &ldquo;START&rdquo; means &ldquo;start the camera&rdquo;. On the other end the server is able to look up the command:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Server<span style=color:#f92672>::</span>OnAppServiceRequest(AppServiceConnection <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span>, AppServiceRequestReceivedEventArgs <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> args)
{
    <span style=color:#66d9ef>auto</span> deferral <span style=color:#f92672>=</span> args.GetDeferral();
    <span style=color:#66d9ef>auto</span> command <span style=color:#f92672>=</span> message.TryLookup(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;COMMAND&#34;</span>);

    <span style=color:#75715e>// handle command (e.g. start camera)
</span><span style=color:#75715e></span>}
</code></pre></div><p>You could use the app service to model a much more complicated contract between client and server.</p>
<p>When it comes to delivering the frames though, we have to take another approach.
I&rsquo;m using a camera that is able to deliver a whopping 120fps of high resolution image data, thats roughly 1-2MB every 8ms. Transferring that much data can be really expensive, especially when running all day long with other programs eating CPU resources as well.<br>
For this part I decided to use the fastest interprocess communication technique there is: shared memory.</p>
<h4 id=shared-memory>Shared memory</h4>
<p>Shared memory is memory that may be accessed by multiple apps simultaneously. Most operating systems also allow the creation of named shared memory, where you give the memory a fixed name. This simplifies access from another app, since all you need is a string representation of the name you chose. I&rsquo;m using named shared memory to transfer the camera frames between client and server without noticeable overhead.</p>
<p>Creating or opening shared memory in UWP is pretty simple. The other way around is&mldr;a bit complicated.
Sadly, I didn&rsquo;t know that at this point in time, so I tried to create the mapping from the Win32 side. Turns out you have to create the mapping with <strong>very</strong> specific security attributes to be able to access it on the UWP side. Luckily, I found <a href=https://docs.microsoft.com/en-us/windows/win32/api/securityappcontainer/nf-securityappcontainer-getappcontainernamedobjectpath>this sample code</a> for creating a named object that&rsquo;s accessible for UWP apps. I can&rsquo;t recommend to do it this way, but it works and I&rsquo;m leaving it as tribute to the dev who wrote the helpful sample code.</p>
<p>The code in question actually creates a named mutex, but switching the flags to the ones for file mappings worked. Simply change the <code>EXPLICIT_ACCESS</code> fields like so:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// ... instead of
</span><span style=color:#75715e>// ea[0].grfAccessMode = SET_ACCESS;
</span><span style=color:#75715e>// ea[0].grfAccessPermissions = STANDARD_RIGHTS_ALL | MUTEX_ALL_ACCESS;
</span><span style=color:#75715e></span>
<span style=color:#75715e>// use:
</span><span style=color:#75715e></span>ea[<span style=color:#ae81ff>0</span>].grfAccessMode <span style=color:#f92672>=</span> GRANT_ACCESS;
ea[<span style=color:#ae81ff>0</span>].grfAccessPermissions <span style=color:#f92672>=</span> STANDARD_RIGHTS_ALL <span style=color:#f92672>|</span> FILE_ALL_ACCESS;

<span style=color:#75715e>// don&#39;t forget to change ea[1] too...
</span></code></pre></div><p>Then create the memory mapping (error handling omitted for brevity):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Server<span style=color:#f92672>::</span>CreateSharedMemory(std<span style=color:#f92672>::</span>wstring name, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> size)
{
    SECURITY_ATTRIBUTES securityAttributes;
    SetSecurityAttributes(securityAttributes);   <span style=color:#75715e>// use sample code to set attributes
</span><span style=color:#75715e></span>
    m_mappingHandle <span style=color:#f92672>=</span> CreateFileMapping(
        INVALID_HANDLE_VALUE,
        <span style=color:#f92672>&amp;</span>securityAttributes,
        PAGE_READWRITE,
        <span style=color:#ae81ff>0</span>,
        size,
        name.c_str());

    m_buffer <span style=color:#f92672>=</span> MapViewOfFile(
        m_mappingHandle,
        FILE_MAP_ALL_ACCESS,
        <span style=color:#ae81ff>0</span>,
        <span style=color:#ae81ff>0</span>,
        size);
}
</code></pre></div><p>As I mentioned, using it from UWP is easy :</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>OpenSharedMemory(std<span style=color:#f92672>::</span>wstring name, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> size)
{
    m_mappingHandle <span style=color:#f92672>=</span> OpenFileMapping(
        FILE_MAP_ALL_ACCESS,
        FALSE,
        name.c_str());

    m_buffer <span style=color:#f92672>=</span> MapViewOfFile(
        m_mappingHandle,
        FILE_MAP_WRITE,
        <span style=color:#ae81ff>0</span>,
        <span style=color:#ae81ff>0</span>,
        size);
}
</code></pre></div><h4 id=ringbuffer>Ringbuffer</h4>
<p>Of course you can&rsquo;t just drop a block of memory in on one end and expect the other side to always read it in time. I&rsquo;m using a fixed-size ringbuffer to coordinate the reads and writes inside the shared memory. The structure of a (naive) ringbuffer is quite easy to explain: there&rsquo;s a write index, a read index and some memory divided into equal-sized slots.</p>
<p>Once the camera produces a frame, the server converts it to a common format and writes directly into a free buffer slot. The server then increments the write index and moves on. If there&rsquo;s no free slot the frame is skipped.</p>
<p>Processing on the client side is done by getting a pointer to a slot and calling the Vuforia Engine with a pointer to the frame data. There&rsquo;s no unnecessary copying involved, which makes this very fast. Once Vuforia is done processing the client increments its read index and moves on as well.</p>
<p><img src=/img/vuforia_external_ringbuffer.jpg alt=Ringbuffer></p>
<p>The nice thing about this lock-free implementation is that, at least in theory, both client and server can process at their own pace. Of course, the implementation described below is only applicable for a single producer and a single consumer. There far more sophisticated solutions out there for multi-producer or multi-consumer setups.</p>
<p>With that being said, here is a simplification of the structures of the ringbuffer to demonstrate the general idea:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Frame</span> {
    <span style=color:#66d9ef>uint64_t</span> timestamp;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> data[MAX_FRAME_SIZE];
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> Capacity<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RingBuffer</span> {
    <span style=color:#66d9ef>int</span> readIndex;
    <span style=color:#66d9ef>int</span> writeIndex;

    T items[Capacity];
};

<span style=color:#66d9ef>typedef</span> RingBuffer<span style=color:#f92672>&lt;</span>Frame, <span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> FrameRingBuffer;
</code></pre></div><p>In this case <code>FrameRingBuffer</code> would be a fixed-size buffer with four slots for frames. Each slot would contain a <code>Frame</code> structure that consists of a timestamp and the raw frame data. As long as you&rsquo;re not using structures that rely on pointers inside the shared memory, you&rsquo;re free to put in whatever you want.</p>
<p>The following code snippet demonstrates how a client could access the latest slot:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>auto</span> <span style=color:#66d9ef>const</span> currentRead <span style=color:#f92672>=</span> buffer.readIndex;

<span style=color:#75715e>// handle slow producer / empty buffer 
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (currentRead <span style=color:#f92672>==</span> buffer.writeIndex) {
    <span style=color:#66d9ef>return</span>;
}

<span style=color:#75715e>// get a pointer to the slot
</span><span style=color:#75715e></span>T<span style=color:#f92672>*</span> pSlot <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(buffer.items[currentRead]);
</code></pre></div><h3 id=the-end>The end</h3>
<p>In the end, all the research and testing was worth it. The important thing for me is that the team was able to use the approach described in this article and deliver on time.</p>
<p>I learned a lot about low-level interprocess communication during this project, and also how rusty my C++ is.
I hope this post helps anyone interested in undertaking a similar endeavour.</p>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user"> </div>
</div>
</footer>
<script src=https://janniklassahn.com/assets/main.js></script>
<script src=https://janniklassahn.com/assets/prism.js></script>
</div>
</body>
</html>